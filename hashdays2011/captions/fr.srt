1
00:00:05,075 --> 00:00:10,098
Quel processeur bizarre - faire des misères au x86... et un peu de PE [Portable Executable]

2
00:00:10,098 --> 00:00:19,048
Bienvenue... et surtout, dites-moi si je vais trop vite

3
00:00:19,048 --> 00:00:28,025
Je vais parler des opcodes, et un peu du format PE et de leurs bizarreries

4
00:00:28,025 --> 00:00:35,008
Je fais du reverse depuis quelque temps. J'ai créé un projet appelé Corkami.

5
00:00:35,008 --> 00:00:42,039
Dans le passé, j'ai participé à Mame, l'émulateur Arcade, et professionellement, analyste de virus,

6
00:00:42,039 --> 00:00:48,018
mais je suis ici à titre personnel, ce sont mes propres expériences à la maison.

7
00:00:48,018 --> 00:00:57,010
Donc, je viens de mentionner Corkami. C'est le nom du projet de mon projet de reverse [rétro-ingénierie]

8
00:00:57,010 --> 00:01:03,073
Je n'y parle que de choses techniques, pas de pubs, pas de login requis

9
00:01:03,073 --> 00:01:06,057
Directement le pur jus.

10
00:01:06,057 --> 00:01:12,040
J'essaie de le maintenir à jour, et util. J'ai créé des fiches pense-bêtes et d'autre documents

11
00:01:12,040 --> 00:01:15,081
que j'utilise moi-même au boulot, au quotidien

12
00:01:15,081 --> 00:01:18,064
mais c'est juste un loisir. je commence quand les enfants sont couchés

13
00:01:18,064 --> 00:01:23,020
tard dans la nuit, donc ça n'a probablement pas le polish professionel

14
00:01:23,020 --> 00:01:25,028
que j'aimerais qu'il ait.

15
00:01:25,028 --> 00:01:30,058
Actuellement, Corkami est un wiki et des pense-bêtes

16
00:01:30,058 --> 00:01:37,059
et je me focalise sur la création de preuves de concepts [démonstration d'hypothèse, "proof of concept] [Tiens, salut Bob!]

17
00:01:37,059 --> 00:01:42,088
donc les binaires sont fait-main, d'habitude je n'utilise pas de compilateurs, je créé la structure du PE à la main

18
00:01:42,088 --> 00:01:46,040
pour que ce soit focalisé sur le point pertinent

19
00:01:46,040 --> 00:01:49,004
et qu'on est pas de parasites. on n'a probablement pas besoin d'IDA

20
00:01:49,004 --> 00:01:51,040
pour comprendre ce qui se passe

21
00:01:51,040 --> 00:01:54,098
car je me concentre uniquement sur ce qui est important.

22
00:01:54,098 --> 00:01:58,028
Les binaires sont directement téléchargables pour que vous puissiez

23
00:01:58,028 --> 00:02:01,030
tester avec votre débogueur, vos outils, vos connaissances,

24
00:02:01,030 --> 00:02:03,084
directement.

25
00:02:03,084 --> 00:02:07,068
pour l'instant, je me suis concentré sur le PDF, l'assembleur et le format PE

26
00:02:07,068 --> 00:02:11,024
quelquest autres trucs, mais ce sont les sujets les plus approfondis

27
00:02:11,024 --> 00:02:15,008
du site, et je partage tout ça avec une licence

28
00:02:15,008 --> 00:02:19,084
très permissive, BSD, donc vous pouvez réutiliser commerciallement

29
00:02:19,084 --> 00:02:24,061
Même les images sont en format ouvert.

30
00:02:24,061 --> 00:02:29,036
Donc, la raison de cette présentation... il y a quelque temps,

31
00:02:29,036 --> 00:02:32,040
J'étais jeune et innocent, et je pensais que les CPUs, fait de transistors,

32
00:02:32,040 --> 00:02:38,045
était parfaitement logique

33
00:02:38,045 --> 00:02:41,061
et ensuite, un virus m'a piégé... simplement,

34
00:02:41,061 --> 00:02:46,059
IDA était rendu inutile. Donc j'ai décidé de repartir à zéro

35
00:02:46,059 --> 00:02:49,078
et d'étudier l'assembleur et le PE du début.

36
00:02:49,078 --> 00:02:52,091
j'ai écrit en chemin des documents, partagés sur Corkami

37
00:02:52,091 --> 00:02:57,066
et maintenant je vous présente le résultat plus ou moins final,

38
00:02:57,066 --> 00:03:01,063
ou du moins quelques buts atteints. Si j'étais juste un gars qui a étudié l'assembleur

39
00:03:01,063 --> 00:03:05,048
je ne serais probablement pas en train de présenter ici,

40
00:03:05,048 --> 00:03:10,058
à moins d'avoir eu quelques résultats avec certains outils.

41
00:03:10,058 --> 00:03:13,087
Donc, pour résumér, j'ai trouvés des bugs dans tous les désassembleurs que j'ai essayé

42
00:03:13,087 --> 00:03:22,010
et j'ai aussi obtenus quelques plantages. J'insiste que tous les auteurs ont été contactés

43
00:03:22,010 --> 00:03:26,009
et que la plupart des problèmes ont déjà été corrigé,

44
00:03:26,009 --> 00:03:30,091
mais en tout cas, en version 6.1, il plante directement, mais dans la version 6.2

45
00:03:30,091 --> 00:03:33,034
c'est corrigé.

46
00:03:33,034 --> 00:03:37,047
et la derniere version de Hiew [Hacker's view] (enfin, pas la dernière publique)

47
00:03:37,047 --> 00:03:41,043
corrige ça aussi.

48
00:03:41,043 --> 00:03:44,087
Donc, pour cette présentation, je commencerais facile,

49
00:03:44,087 --> 00:03:50,085
je pars du principe que vous êtes tous habitués à l'assembleur ?

50
00:03:50,085 --> 00:03:57,035
Oui. et vous êtes tous habitués, ou

51
00:03:57,035 --> 00:04:02,092
vous avez déjà rencontré des cas d'opcodes non documentés?

52
00:04:02,092 --> 00:04:06,017
Genre vous faites confiance à IDA, point barre.

53
00:04:06,017 --> 00:04:10,056
Est-ce habituel de voir quelque chose non géré par IDA ?

54
00:04:10,056 --> 00:04:14,036
Levez les bras... ok, pas tant que ça.

55
00:04:14,036 --> 00:04:19,056
Bon, après l'introduction en accéléré,

56
00:04:19,056 --> 00:04:25,036
Je parlerais de quelques techniques, puis présenterai CoST, mon programme

57
00:04:25,036 --> 00:04:28,095
et je parlerais aussi un peu du format PE

58
00:04:28,095 --> 00:04:34,008
Bon, vous connaissez tous l'assembleur, on va survoler ...

59
00:04:34,008 --> 00:04:37,092
Donc, on compile un binaire, il y a de l'assembleur, il y a

60
00:04:37,092 --> 00:04:44,025
un rapport, des points communs entre le code source et l'assembleur généré...

61
00:04:44,025 --> 00:04:48,076
et bien sûr, une relation entre langage machine et les opcodes

62
00:04:48,076 --> 00:04:53,060
ce qui est important est que l'assembleur est généré par le compilateur, mais ce qui reste

63
00:04:56,068 --> 00:04:59,076
dans le binaire, sont uniquement les opcodes, qui sont interprétés

64
00:04:59,076 --> 00:05:03,034
directement par le processeur, ce qui implique qu'il sache quoi faire avec,

65
00:05:03,034 --> 00:05:07,039
il s'en fiche si vous ou vos outils

66
00:05:07,039 --> 00:05:10,087
ne savent pas ce qui va arriver. il le fait, tout simplement.

67
00:05:10,087 --> 00:05:16,016
Et le problème, c'est que d'habitude, on ne lit pas les opcodes directement, mais le désassemblage

68
00:05:16,016 --> 00:05:20,060
donc si le désassemblage échoue, on est bloqué

69
00:05:20,060 --> 00:05:25,043
on est aveugle, on ne sait pas ce qui va s'exécuter

70
00:05:25,043 --> 00:05:28,009
l'autre problème est comme les instructions sont de longueurs variables

71
00:05:28,009 --> 00:05:30,032
on ne sait pas ou la suivante commence

72
00:05:30,032 --> 00:05:32,032
donc même la suite est inconnue.

73
00:05:32,032 --> 00:05:40,017
Donc, on créé une seule instruction non documentée dans un programme simple

74
00:05:40,017 --> 00:05:48,063
on utilise le mot-clef 'emit' -- c'est Visual Studio 2010 ultimate --

75
00:05:48,063 --> 00:05:52,024
et on obtient un octet non identifié au désassemblage

76
00:05:52,024 --> 00:05:58,043
on a des juste points d'interrogations.

77
00:05:58,043 --> 00:06:01,076
et donc, même si Visual Studio coûte plusieurs milliers d'euros

78
00:06:01,076 --> 00:06:05,001
il ne sait pas ce qui va se produire....

79
00:06:05,001 --> 00:06:09,010
et si on regarde les documentations Intel

80
00:06:09,010 --> 00:06:14,025
circulez, il y a rien a voir... l'opcode D6... inconnu au bataillon

81
00:06:14,025 --> 00:06:17,091
Microsoft n'a rien à dire, Intel non plus,

82
00:06:17,091 --> 00:06:21,013
donc d'habitude, si vous essayez des choses comme ça, attendez-vous au pire.

83
00:06:21,013 --> 00:06:26,056
Donc, aucune information... en général, ça annonce un plantage...

84
00:06:26,056 --> 00:06:29,072
mais dans ce cas particulier, aucun problème...

85
00:06:29,072 --> 00:06:35,029
nous ne savons pas ce qui se passe, si on regarde les docs Intel et Microsoft, on n'en sait pas plus.

86
00:06:35,029 --> 00:06:41,028
Mais le CPU a juste fait son boulot dans son coin. Ce qui s'est passé est qu'en fait

87
00:06:41,028 --> 00:06:49,013
D6 est un opcode très simple, qui ne fait pas grand chose, mais pas documenté par Intel,

88
00:06:49,013 --> 00:06:53,096
par contre, il l'est par AMD, et la plupart le sont aussi également, par AMD mais pas Intel

89
00:06:53,096 --> 00:06:58,019
aucune idée pourquoi. si quelqu'un le sait...

90
00:06:58,019 --> 00:07:04,013
c'est un opcode pourtant trivial, pourtant... 'y a rien à voir, continuez votre chemin'

91
00:07:04,013 --> 00:07:08,031
Il est utilisé souvent... l'utilisation habituelle de tels opcodes sont les virus et les packeurs

92
00:07:08,031 --> 00:07:13,031
pour éviter les analyses automatisées où trop facile.

93
00:07:13,031 --> 00:07:22,029
Ce qui est ironique, c'est que si vous regardez la doc, elle est pleine de trous. mais le désassembleur d'Intel,

94
00:07:22,029 --> 00:07:25,021
Xed, qui est gratuit mais pas ouvert, gère tous ces opcodes sans problème...

95
00:07:25,021 --> 00:07:35,057
Alors que Microsoft, Visual Studio, et WinDBG, suivent la documentation aveuglément

96
00:07:35,057 --> 00:07:43,007
Donc vous obtiendrez des points d'interrogation alors qu'Intel sait très bien ce qui se passe

97
00:07:43,007 --> 00:07:52,033
'faites ce que je fais, pas ce que je dit'

98
00:07:52,033 --> 00:08:01,016
donc, bien sûr, vous me direz que WinDbg est fait uniquement ce qui est généré

99
00:08:01,016 --> 00:08:08,008
par les compilateurs Microsoft, mais ça exclut WinDBG comme outil d'analyse de virus:

100
00:08:08,008 --> 00:08:17,060
vous rajoutez D6, trivial, et WinDbg est muet.

101
00:08:17,060 --> 00:08:25,059
pas génial

102
00:08:25,059 --> 00:08:32,075
un autre problème est que toutes ses choses non documentées

103
00:08:32,075 --> 00:08:37,063
sont peut-être présentes, l'une dans un virus,

104
00:08:37,063 --> 00:08:42,040
l'autre dans un packeur, etc... donc il n'est pas facile

105
00:08:42,040 --> 00:08:46,058
de trouver un bon regroupement de tels fichiers pour rassembler toutes ces informations

106
00:08:46,058 --> 00:08:50,025
donc par exemple,

107
00:08:50,025 --> 00:08:53,050
quelqu'un vous parle d'une astuce

108
00:08:53,050 --> 00:08:55,087
et vous dit qu'elle est enfouit dans MebRoot (un virus costaud)

109
00:08:55,087 --> 00:08:58,072
donc vous êtes obligé de creuser pour voir juste la partie qui vous intéresse

110
00:08:58,072 --> 00:09:03,097
et en plus, on sait que c'est un virus, donc ca ne circule pas facilement,

111
00:09:03,097 --> 00:09:08,063
et il y a plein de trucs dedans qui n'on rien à voir dedans,

112
00:09:08,063 --> 00:09:15,012
avant ou après ce qui vous intéresse. Donc c'est le fossé que je veux remplir en fournissant

113
00:09:15,012 --> 00:09:21,017
un groupe de fichier à la fois simple et complet, et focalisé.

114
00:09:21,017 --> 00:09:27,079
Donc, on commence. enfin, du vrai, quelques opcodes non documentés.

115
00:09:27,079 --> 00:09:37,010
Mais avant d'avoir commencé à étudier, je me suis demandé quelles étaient les vrais capacités

116
00:09:37,010 --> 00:09:44,055
des processeurs, quelles instructions existent vraiment.

117
00:09:44,055 --> 00:09:52,024
C'est un peu comme l'anglais: la plupart de la population mondiale comprend ces mots, et

118
00:09:52,024 --> 00:09:57,072
si vous avez déjà désassemblé quelque chose, vous êtes habitués à ces instructions

119
00:09:57,072 --> 00:10:04,032
tous les compilateurs les utilisent. elles sont tellement répandues que si elles sont absentes,

120
00:10:04,032 --> 00:10:08,068
on se sent pris au dépourvu.

121
00:10:08,068 --> 00:10:19,074
mais les processeurs Intels datent des années 70. Donc,

122
00:10:19,074 --> 00:10:27,072
comme l'anglais de Shakespeare, vous voyez que c'est de l'anglais... mais, ça veut dire quoi en fait ?

123
00:10:27,072 --> 00:10:30,051
d'ailleurs, j'ai déjà oublié

124
00:10:30,051 --> 00:10:36,032
ces instructions sont toutes gérées par tous nos processeurs, pourtant, on n'a plus l'habitude de les lire

125
00:10:36,032 --> 00:10:41,098
c'est plus que génant

126
00:10:41,098 --> 00:10:46,084
En fait, j'ai écrit un example qui n'utilisent que ces vieilles instructions, qui font vraiment quelque chose

127
00:10:46,084 --> 00:10:53,015
donc si vous vous sentez ici comme chez vous, je voudrais vous demander 'quel âge avez-vous ?'

128
00:10:53,015 --> 00:10:59,072
parce que même moi, j'ai l'habitude de PUSH/JUMP/CALLs, mais ça, euhh...

129
00:10:59,072 --> 00:11:05,084
pourtant, ça marche même sur un i7, et c'est utilisable par les virus,

130
00:11:05,084 --> 00:11:13,098
les packeurs, etc... pourtant, la plupart est complètement inutilisée de nos jours, bien que parfaitement

131
00:11:13,098 --> 00:11:15,097
gérées par nos processeurs modernes.

132
00:11:15,097 --> 00:11:21,044
Et, tel l'anglais, c'est une langue qui évolue, et les générations précedentes

133
00:11:21,044 --> 00:11:27,072
n'ont pas l'habitude des derniers mots à la mode.

134
00:11:27,072 --> 00:11:35,020
Ces instructions sont parfois présentes sur les processeurs les plus récent. en une seule instruction, on fait

135
00:11:35,020 --> 00:11:41,036
un CRC32, on décrypte l'AES, on compare des chaînes, ou d'autres opérations complexes.

136
00:11:41,036 --> 00:11:47,067
Donc, c'est possible sur un processeur moderne. pas tous, bien sûr.

137
00:11:47,067 --> 00:11:54,063
une que j'aime bien est MOVBE -- move big endian -- parce que c'est le vilain petit canard du lot...

138
00:11:54,063 --> 00:12:01,087
uniquement implémentée sur les processeurs Atom, donc comme ce netbook, qui la gère...

139
00:12:01,087 --> 00:12:09,038
alors qu'un i7 64-bits ne l'a pas, même si lui aura CRC32, peut-être AES, etc...

140
00:12:09,038 --> 00:12:12,054
donc, tant pis pour la retro-compatibilité

141
00:12:12,054 --> 00:12:20,029
à ma connaissance, il n'y existe aucun processeur qui gère à la fois CRC32 et MOVBE.

142
00:12:20,029 --> 00:12:24,084
De plus, MOVBE est un peu inutile car il fait la même chose que MOV et BSWAP réunit...

143
00:12:24,084 --> 00:12:32,004
donc, bizarre. en tout cas, ce mini-PC a une instruction que la plupart des PC n'ont pas

144
00:12:32,004 --> 00:12:35,025
Pourquoi ? quelqu'un sait?

145
00:12:35,025 --> 00:12:37,085
[Auditeur:] "cette instruction est documentée ?"

146
00:12:37,085 --> 00:12:38,078
oui

147
00:12:38,078 --> 00:12:42,086
totallement documentée officiellement

148
00:12:42,086 --> 00:12:46,082
[Auditeur:] "Mais, c'est un drapeur du processeur juste pour cette instruction, ou implicitement lié au

149
00:12:46,082 --> 00:12:51,036
processeurs Atom ?

150
00:12:51,036 --> 00:12:58,039
mmm, je ne sais pas. je verifie la valeur par CPUID, mais j'ai oublié la définition exacte.

151
00:12:58,039 --> 00:13:07,055
il y a tant d'informations données par CPUID que j'ai vite oublié.

152
00:13:07,055 --> 00:13:13,061
Autre chose, spécifique à Windows, car je m'intéresse aux virus...

153
00:13:13,061 --> 00:13:22,052
avant d'exécuter quoi que ce soit, je me demandais quelle était la valeur initiale de chaque registre

154
00:13:22,052 --> 00:13:28,072
quand le programme démarre.

155
00:13:28,072 --> 00:13:33,063
et ça vous donne en fait de l'information fiable, qu'on retrouve utilisée par les virus

156
00:13:33,063 --> 00:13:40,054
donc par example, au demarrage, EAX vous dit si vous êtes sur un OS ancien (XP ou avant)

157
00:13:40,054 --> 00:13:42,084
ou plus récent, Vista ou 7.

158
00:13:42,084 --> 00:13:50,079
de même, ce n'est pas utilisé par les virus à mon souvenir, mais si GS est nul, on est dans un OS 32 bits

159
00:13:50,079 --> 00:13:54,029
sinon, sur un 64b.

160
00:13:54,029 --> 00:13:56,094
J'utilise ça régulièrement, on le verra plus tard.

161
00:13:56,094 --> 00:14:04,032
De même, la relation entre les registres n'est pas forcément évidente. il y en a beaucoup,

162
00:14:04,032 --> 00:14:10,077
et j'ai été surpris qu'une instruction à virgule flottante (FPU) change le status (FST), les registres

163
00:14:10,077 --> 00:14:18,051
eux-mêmes (STx), les registres MMx aussi, mais en plus, toutes les documentations en ligne associent

164
00:14:18,051 --> 00:14:24,094
ST0 et MM0, ce qui semble logique, alors qu'en fait, une seule instruction modifie

165
00:14:24,094 --> 00:14:31,039
non pas MM0, mais MM7, dans l'autre sens.

166
00:14:31,039 --> 00:14:36,075
donc après une instruction comme "load PI" [FLDPI] on regarde la valeur de MM7,

167
00:14:36,075 --> 00:14:39,043
ça peut-être utilisé comme astuce simple.

168
00:14:39,043 --> 00:14:45,093
alors que toutes les documentations, wikipedia ou autre, se trompent.

169
00:14:45,093 --> 00:14:53,032
quelque chose d'autre qui peut être utilisé comme anti-débogueur sous XP: le FPU modifie aussi CR0

170
00:14:53,032 --> 00:14:59,077
donc ça fait une astuce anti-émulateur plutôt inattendue rien qu'avec le FPU.

171
00:14:59,077 --> 00:15:09,001
'store machine status word' [SMSW] est une instruction qui date du 286, quand le mode protégé était

172
00:15:09,001 --> 00:15:18,048
récent et incomplet, qui permet de lire les valeurs de CR0, même depuis le mode utilisateur.

173
00:15:18,048 --> 00:15:26,096
alors que 'MOV CR0' est privilégiée

174
00:15:26,096 --> 00:15:34,012
pour une raison inconnue, le mot de poid fort est officiellement non défini.

175
00:15:34,012 --> 00:15:40,044
donc à priori, on ne sait pas ce qu'il va contenir,

176
00:15:40,044 --> 00:15:45,072
mais en fait il s'agit bien du même mot de poid fort que CR0.

177
00:15:45,072 --> 00:15:52,091
et, sous XP, après une instruction FPU, la valeur de CR0 est modifiée, mais reprend sa valeur initiale

178
00:15:52,091 --> 00:16:00,033
toute seule par la suite. donc juste avec SMSW, verifier le résultat, puis faire une opération FPU,

179
00:16:00,033 --> 00:16:05,091
alors SMSW donnera un résultat différent, mais ensuite, le résultat redeviendra comme à l'origine.

180
00:16:05,091 --> 00:16:11,001
un moyen élégant de faire des boucles en apparence infinies. une astuce complexe anti-émulateurs.

181
00:16:11,001 --> 00:16:18,087
Une astuce similaire sous Windows 32b, où GS n'est pas stocké dans le CONTEXT, donc quand l'OS passe d'un

182
00:16:18,087 --> 00:16:25,068
fil d'exécution à l'autre (thread-switch), GS est remis à zero. Donc, si on attend, quoi qu'on fasse,

183
00:16:25,068 --> 00:16:33,035
GS change comme par enchantement. Mais si vous faites du pas à pas, c'est lent, donc l'OS change de fil,

184
00:16:33,035 --> 00:16:40,051
et GS est perdu dès l'instruction suivante.

185
00:16:40,051 --> 00:16:45,067
De même, si on attend que GS devienne nul, on finira par sortir de la boucle.

186
00:16:45,067 --> 00:16:53,012
En tout cas, la première fois, ça défiait mon entendement... sans autres process ou autre, je ne comprenais

187
00:16:53,012 --> 00:16:58,072
pas d'où ça venait. Au moins, mon example commence dès le début avec ça

188
00:16:58,072 --> 00:17:02,091
c'est plus pratique

189
00:17:02,091 --> 00:17:11,000
une autre particularité, c'est que ça met du temps pour être remis à zéro. en faisant 2 boucles d'attentes,

190
00:17:11,000 --> 00:17:17,051
et mesurant le temps entre les 2 (changement de fil), ça prend somme toute assez longtemps, comparé à une

191
00:17:17,051 --> 00:17:25,054
exécution standard. ça fait un anti-émulation solide.

192
00:17:25,054 --> 00:17:33,020
Je pensais tout naturellement que NOP était parfait! NOP, c'est NOP, ça ne fait rien, donc, aucun problème !

193
00:17:33,020 --> 00:17:44,013
Mais à l'origine, NOP est 'échange ?AX avec lui-même' (xchg ?ax, ?ax) mais c'est le cas pour le NOP encodé 0x90

194
00:17:44,013 --> 00:17:51,020
mais il y a un autre encodage de XCHG EAX, EAX, qui ne fait rien non plus en 32b

195
00:17:51,020 --> 00:17:54,064
mais, à l'instar de toutes les instructions sur 32b en mode 64b

196
00:17:54,064 --> 00:17:58,075
cette instruction remet à zéro le double mot de poid fort

197
00:17:58,075 --> 00:18:02,075
donc on a un XCHG EAX [,EAX] qui fait quelque chose.

198
00:18:02,075 --> 00:18:05,075
bien qu'initialement il semblerait ne rien faire, de sa relation avec NOP

199
00:18:05,075 --> 00:18:10,020
mais heureusement, le NOP 0x90, lui, ne fait toujours rien, un vrai fainéant ;)

200
00:18:10,020 --> 00:18:14,017
Celui-ci est maintenant bien répandu,

201
00:18:14,017 --> 00:18:18,049
le HINT NOP est un NOP sur plusieurs octets

202
00:18:18,049 --> 00:18:23,041
qui indique au processeur ce qui va être exécuté ou accédé ensuite

203
00:18:23,041 --> 00:18:24,051
quelque soit l'adresse dans un HINT NOP en mémoire,

204
00:18:24,051 --> 00:18:26,026
aucune exception n'est déclenchée

205
00:18:26,026 --> 00:18:32,031
mais ...

206
00:18:32,031 --> 00:18:37,024
autre chose, il est partiellement non documenté par Intel

207
00:18:37,024 --> 00:18:44,055
(comme d'habitude, ce n'est pas le cas avec AMD)

208
00:18:44,055 --> 00:18:48,040
en outre, comme c'est une instruction sur plusieurs octets, avec des opérandes immédiates

209
00:18:48,040 --> 00:18:51,076
si on met ces octets à la fin d'une page mémoire

210
00:18:51,076 --> 00:18:55,001
alors le processeur va vouloir lire l'encodage des opérandes,

211
00:18:55,001 --> 00:18:56,064
et ça va déclencher une exception

212
00:18:56,064 --> 00:19:01,040
donc c'est un NOP qui peut déclencher une exception en bas de page

213
00:19:01,040 --> 00:19:04,059
Merci, Intel

214
00:19:04,059 --> 00:19:07,008
MOV également, je croyais...

215
00:19:07,008 --> 00:19:11,040
qu'il devrait être parfaitement logique

216
00:19:11,040 --> 00:19:16,009
mais, même s'il est documenté, il y a des cas compliqués,

217
00:19:16,009 --> 00:19:19,076
qui n'étaient pas parfaitement gérés dans tous les assembleurs que j'ai essayé

218
00:19:19,076 --> 00:19:22,092
sauf peut-être Xed

219
00:19:22,092 --> 00:19:29,055
on ne peut pas faire un MOV de ou vers CR0 en mémoire,

220
00:19:29,055 --> 00:19:33,000
la documentation dit que le Mod/RM est ignoré

221
00:19:33,000 --> 00:19:34,016
ce qui ne veut pas dire que l'instruction est invalide

222
00:19:34,016 --> 00:19:35,009
simplement, considéré comme n'utilisant pas la mémoire

223
00:19:35,009 --> 00:19:36,079
sinon, ça ferait un plantage

224
00:19:36,079 --> 00:19:39,051
donc, voici l'équivalent

225
00:19:39,051 --> 00:19:42,033
ce qui mettait en tord tous les désassembleurs

226
00:19:42,033 --> 00:19:44,042
jusque récemment

227
00:19:44,042 --> 00:19:50,009
MOVSXD est une instruction 64b, qui étend un registre

228
00:19:50,009 --> 00:19:55,040
donc, d'un registre vers un plus gros

229
00:19:55,040 --> 00:19:58,026
mais sans préfixe REX - ce qui n'est pas encouragé,

230
00:19:58,026 --> 00:20:02,002
on peut l'utiliser comme un MOV standard, de 32b vers 32b

231
00:20:02,002 --> 00:20:04,035
et dans l'autre sens,

232
00:20:04,035 --> 00:20:09,092
MOV d'un selecteur à un registre 32b marche sans problème,

233
00:20:09,092 --> 00:20:13,024
alors que beaucoup de désassembleurs afficheraient MOV AX, CS, ce qui semble logique

234
00:20:13,024 --> 00:20:16,009
niveau taille

235
00:20:16,009 --> 00:20:19,075
mais en fait le mot de poid fort du registre cible est 'non défini'

236
00:20:19,075 --> 00:20:21,081
mais ici, pas de surprise amusante,

237
00:20:21,081 --> 00:20:25,024
ce sont juste des zéros

238
00:20:25,024 --> 00:20:30,040
donc c'est équivalent à MOV EAX, CS

239
00:20:30,040 --> 00:20:32,058
BSWAP est un de mes favoris

240
00:20:32,058 --> 00:20:35,016
parce que je le compare à une administration:

241
00:20:35,016 --> 00:20:38,025
il est supposé passer d'un endianisme [endianness] à l' autre

242
00:20:38,025 --> 00:20:42,083
mais pour diverses raisons,

243
00:20:42,083 --> 00:20:45,020
il ne peut jamais faire son travail correctement

244
00:20:45,020 --> 00:20:50,041
donc, c'est juste en 64b que tout se passe

245
00:20:50,041 --> 00:20:51,096
comme prévu

246
00:20:51,096 --> 00:20:55,096
en 32b, comme toutes les autres instruction 32b

247
00:20:55,096 --> 00:20:59,033
le double mot de poid fort est mis à zéro...

248
00:20:59,033 --> 00:21:02,072
et sur un mot, il est non défini officiellement,

249
00:21:02,072 --> 00:21:04,020
mais il est pourtant utilisé couramment dans les virus et les packeurs

250
00:21:04,072 --> 00:21:07,008
car il remet simplement à zéro le registre,

251
00:21:07,008 --> 00:21:09,055
comme un simple XOR AX, AX

252
00:21:09,055 --> 00:21:14,051
donc, devant un résultat si inexplicable, je comprends

253
00:21:14,051 --> 00:21:18,072
qu'Intel ne veuille pas en parler

254
00:21:18,072 --> 00:21:20,092
ça serait sûrement génant de devoir expliquer

255
00:21:20,092 --> 00:21:24,072
ce résultat plutôt comique.

256
00:21:24,072 --> 00:21:33,042
BSWAP AX est aussi mal géré par WinDbg et les autres

257
00:21:33,042 --> 00:21:35,068
on lira BSWAP EAX

258
00:21:35,068 --> 00:21:42,007
alors que le registre est remis à zéro... génant

259
00:21:42,007 --> 00:21:47,040
tout le monde comprend ce code?

260
00:21:47,040 --> 00:21:53,001
quelqu'un voit un piège possible?

261
00:21:53,001 --> 00:21:56,064
l'adresse de <next> est empilée

262
00:21:56,064 --> 00:22:00,040
puis dépilée par RETN

263
00:22:00,040 --> 00:22:05,068
donc, on saute vers une adresse immédiates

264
00:22:05,068 --> 00:22:11,040
l'ordre d'execution ?

265
00:22:11,040 --> 00:22:18,000
oui, l'exécution démarre ici

266
00:22:18,000 --> 00:22:20,096
non, rien à voir ici

267
00:22:20,096 --> 00:22:26,008
voilà OllyDbg 1 - c'est corrigé dans le 2

268
00:22:26,008 --> 00:22:28,026
Olly essaie même d'être sympa et de vous dire

269
00:22:28,026 --> 00:22:30,055
via un commentaire automatique,

270
00:22:30,055 --> 00:22:33,059
que RET sera utilisé comme saut vers <next>

271
00:22:33,059 --> 00:22:36,034
et, voyez le résultat, plutôt différent

272
00:22:36,034 --> 00:22:37,048
donc, que c'est-il passé ?

273
00:22:37,048 --> 00:22:40,024
quelqu'un voit ?

274
00:22:40,024 --> 00:22:43,026
donc, RETN a un prefix 66

275
00:22:43,026 --> 00:22:47,035
donc, il retourne vers IP (16b), pas EIP

276
00:22:47,035 --> 00:22:56,017
donc on ne saute pas vers 401008, mais 00001008

277
00:22:56,017 --> 00:22:58,072
et dans mon exemple, la page nulle a été allouée

278
00:22:58,072 --> 00:23:01,009
 et du code a été placé à 1008

279
00:23:01,009 --> 00:23:06,002
donc, ça ne retourne pas vers [<next>]

280
00:23:06,002 --> 00:23:10,085
mais l'autre problème est que c'est aussi appelé un RETN

281
00:23:10,085 --> 00:23:15,079
bien que ce soit différent. les désassembleurs ont leur propre façon de l'afficher

282
00:23:15,079 --> 00:23:19,055
tel que 'small retn', 'ret.16', ou autre

283
00:23:19,055 --> 00:23:22,075
mais officiellement, c'est la même instruction qu'un RETN standard.

284
00:23:22,075 --> 00:23:28,066
donc, le dernier Hiew, et OllyDbg 1

285
00:23:28,066 --> 00:23:31,017
peut-être pas le 2

286
00:23:31,017 --> 00:23:33,016
mais on peut se faire avoir

287
00:23:33,016 --> 00:23:41,024
et le préfixe 66 a le même role avec CALLs, RETs, LOOPs, JMPs

288
00:23:41,024 --> 00:23:45,083
toutes les instructions contrôlant le flux d'exécution

289
00:23:45,083 --> 00:23:48,027
je ne vais pas tout énumérer

290
00:23:48,027 --> 00:23:51,074
car sinon vous allez mourrir d'ennui

291
00:23:51,074 --> 00:23:55,041
pour en savoir plus, j'ai créé une page sur Corkami [x86.corkami.com],

292
00:23:55,041 --> 00:24:00,075
avec quelques graphiques et penses-bêtes

293
00:24:00,075 --> 00:24:04,075
pour faciliter le boulot

294
00:24:04,075 --> 00:24:06,092
bon, trop de théorie

295
00:24:06,092 --> 00:24:11,088
je n'aime pas lire sans avoir quelque chose à me mettre sous le débogueur,

296
00:24:11,088 --> 00:24:13,066
donc j'ai créé CoST

297
00:24:13,066 --> 00:24:16,000
ce qui signifie Corkami Standard Test

298
00:24:16,000 --> 00:24:20,003
CoST est un unique binaire, sans option de ligne de commande

299
00:24:20,003 --> 00:24:25,050
on l'exécute, il fait plein de tests

300
00:24:25,050 --> 00:24:28,066
le tout dans un PE compliqué

301
00:24:28,066 --> 00:24:35,016
pour aussi tester vos outils PE

302
00:24:35,016 --> 00:24:36,044
ou vos connaissances

303
00:24:36,044 --> 00:24:40,020
mais, dans ce PE compliqué, il est casse-pied à déboguer

304
00:24:40,020 --> 00:24:42,073
donc j'ai fait aussi une version 'PE standard'

305
00:24:42,073 --> 00:24:47,042
si on ne veut étudier que l'assembleur

306
00:24:47,042 --> 00:24:49,044
sans difficultés

307
00:24:49,044 --> 00:24:57,088
donc, CoST contient de nombreux tests

308
00:24:57,088 --> 00:24:59,075
les classiques, triviaux,

309
00:24:59,075 --> 00:25:03,096
un peu plus compliqués, JMP to IP, IRET...

310
00:25:03,096 --> 00:25:05,031
les non documentés

311
00:25:05,031 --> 00:25:10,041
les spécifiques aux processuers, comme MOVBE, POPCNT, CRC32

312
00:25:10,041 --> 00:25:17,083
les detections d'OS et VM

313
00:25:17,083 --> 00:25:25,048
comme le fameux 'red pill'... juste une instruction SLDT, on compare le résultat,

314
00:25:25,048 --> 00:25:29,017
et on baptise ça 'red pill'... sans commentaire...

315
00:25:29,017 --> 00:25:32,092
et aussi, des bugs des SE, parce que Windows XP

316
00:25:32,092 --> 00:25:35,053
se trompe en essayant de vous dire

317
00:25:35,053 --> 00:25:38,064
quelle exception vient de se produire,

318
00:25:38,064 --> 00:25:44,079
ce qui permettrait de différencier un SE réel d'un émulateur.

319
00:25:44,079 --> 00:25:50,030
CoST est écrit en assembleur, donc rien de superflu

320
00:25:50,030 --> 00:25:52,075
pas compilé, ni généré

321
00:25:52,075 --> 00:25:56,075
mais pour le documenter un peu plus, j'ai ajouté des exports internes

322
00:25:56,075 --> 00:26:00,000
donc on peut aller facilement d'une section à l'autre

323
00:26:00,000 --> 00:26:05,088
donc on se retrouvre facilement à la partie qui nous intéresse

324
00:26:05,088 --> 00:26:08,032
via les exports,

325
00:26:08,032 --> 00:26:13,079
et je voulais pouvoir afficher un message de manière pratique

326
00:26:13,079 --> 00:26:18,058
sans que ça allonge trop le listing

327
00:26:18,058 --> 00:26:21,092
je veux dire, devoir faire défiler l'écran parce qu'il est couvert d'appel à printf

328
00:26:21,092 --> 00:26:25,073
donc j'au utilisé un Vectored Exception Handler, et une instruction-marqueur

329
00:26:25,073 --> 00:26:28,052
donc plein de commentaires sont affichés,

330
00:26:28,052 --> 00:26:30,035
directement dans le code

331
00:26:30,035 --> 00:26:34,088
donc ça fait un code binaire documenté sans fichier de symboles de déboguages

332
00:26:34,088 --> 00:26:38,092
et vous avez vu, il n'y a pas beaucoup d'affichage

333
00:26:38,092 --> 00:26:41,092
mais en fait, il y a beaucoup plus d'affichage de déboguage

334
00:26:41,092 --> 00:26:46,088
une centaine au moins, qui indiquent même ce qui va se produire, etc

335
00:26:46,088 --> 00:26:49,070
donc on est pas pris au dépourvu

336
00:26:49,070 --> 00:26:57,079
on est guidé lors de l'analyse

337
00:26:57,079 --> 00:27:00,028
quelqu'un comprend de quoi il s'agit?

338
00:27:00,028 --> 00:27:02,083
c'est un de mes préférés

339
00:27:02,083 --> 00:27:06,011
on ne peut pas voir les opcodes

340
00:27:06,011 --> 00:27:17,070
ah, il n'y a pas d'astuce à ce niveau là cette fois-ci ;)

341
00:27:17,070 --> 00:27:19,070
donc, on empile des valeurs

342
00:27:19,070 --> 00:27:21,003
on saute ici

343
00:27:21,003 --> 00:27:26,020
et avec le RETF, j'ai empilé l'adresse de 'push_eip'

344
00:27:26,020 --> 00:27:28,052
et un mot, 0x33

345
00:27:28,052 --> 00:27:31,000
donc on va revenir de loin ici

346
00:27:31,000 --> 00:27:35,062
donc on retourne à cette adresse avec un selecteur 33

347
00:27:35,062 --> 00:27:39,020
qui est reservé au mode 64b, même pour un programme en 32b

348
00:27:39,020 --> 00:27:42,078
donc on va revenir ici, en mode 64b

349
00:27:42,078 --> 00:27:47,079
car 33 est le selecteur pour le mode 64b

350
00:27:47,079 --> 00:27:49,083
qu'on peut atteindre depuis un programme 32b

351
00:27:49,083 --> 00:27:56,031
donc le code sera d'abord executé en mode 32b, avec le sélecteur standard,

352
00:27:56,031 --> 00:28:01,096
puis à nouveau, avec le sélecteur 33

353
00:28:01,096 --> 00:28:04,037
en mode 64b

354
00:28:04,037 --> 00:28:08,036
donc on a la même adresse, les mêmes opcodes,

355
00:28:08,036 --> 00:28:10,016
mais le désassemblage sera différent

356
00:28:10,016 --> 00:28:14,024
et j'ai choisi des opcodes qui génèrent des instructions

357
00:28:14,024 --> 00:28:18,020
spécifique à chaque mode

358
00:28:18,020 --> 00:28:22,092
donc, c'est déjà une belle s*loperie à désassembler,

359
00:28:22,092 --> 00:28:27,092
car avec la même EIP, si on ne fait pas attention au sélecteur,

360
00:28:27,092 --> 00:28:29,011
on est bloqué

361
00:28:29,011 --> 00:28:46,068
On peut déboguer un tel code - voir ma présentation à BerlinSides, transparent de démonstration 58

362
00:28:46,068 --> 00:28:50,063
Si on l'execute en passant par dessus, on retourne au sélecteur d'origine

363
00:28:50,063 --> 00:28:52,055
qui était sauvé par le PUSH CS

364
00:28:52,055 --> 00:28:56,029
donc on retourne à <end> avec le sélecteur initial

365
00:28:56,029 --> 00:28:58,071
l'exécution est rapide,

366
00:28:58,071 --> 00:29:00,079
mais difficile à déboguer (uniquement avec WinDbg+wow64exts)

367
00:29:00,079 --> 00:29:03,077
ça rend inutile les désassembleurs, et la plupart des débogueurs

368
00:29:03,077 --> 00:29:04,092
pourtant, c'est si simple.

369
00:29:04,092 --> 00:29:07,035
Voilà ce que donne CoST

370
00:29:07,035 --> 00:29:10,069
sous la dernière version de Hiew

371
00:29:10,069 --> 00:29:13,031
je pense que ce sera bientôt corrigé

372
00:29:13,031 --> 00:29:16,077
c'est un HINT NOP non documenté par Intel

373
00:29:16,077 --> 00:29:21,003
et oublié par la plupart des désassembleurs

374
00:29:21,003 --> 00:29:24,053
donc WinDbg et Hiew

375
00:29:24,053 --> 00:29:29,077
vous donnent des points d'interrogations

376
00:29:29,077 --> 00:29:34,070
au début, je pensais m'arrêter là pour Hashdays

377
00:29:34,070 --> 00:29:39,064
mais j'ai décidé de rajouter quelques astuces PE à CoST

378
00:29:39,064 --> 00:29:43,029
donc, en voici l'en-tête... MZ, puis du texte

379
00:29:43,029 --> 00:29:44,045
donc on peut taper 'type cost.exe', comme ce bon vieux Budokan...

380
00:29:44,045 --> 00:29:46,088
et ensuite,

381
00:29:46,088 --> 00:29:51,079
l'en-tête 'NT headers' - appelé 'PE' car il commence par ces lettres-là,

382
00:29:51,079 --> 00:29:54,075
et en fait à la fin du fichier

383
00:29:54,075 --> 00:29:56,000
le 'pied-de-page PE'

384
00:29:56,000 --> 00:29:59,036
et les valeurs de l'en-tête sont un peu extrême

385
00:29:59,036 --> 00:30:01,035
donc, pour le moins inattendu

386
00:30:01,035 --> 00:30:03,044
donc voici ce qu'IDA 6.1 en pensait

387
00:30:03,044 --> 00:30:07,011
...plantage directe...

388
00:30:07,011 --> 00:30:11,024
ça lui apprendra à se fier aux valeurs

389
00:30:11,024 --> 00:30:15,098
mais, aussi bien dans CoST, on peut changer un registre, faire une comparaison, tester,

390
00:30:15,098 --> 00:30:17,005
et enchaîner ainsi plein de tests,

391
00:30:17,005 --> 00:30:19,065
aussi bien, côté PE, on n'a qu'un seul binaire, donc

392
00:30:19,065 --> 00:30:21,068
un seul essai

393
00:30:21,068 --> 00:30:25,073
donc même si CoST n'a pas de section, des TLS bizarres,....

394
00:30:25,073 --> 00:30:27,079
il ne peut pas tout tester

395
00:30:27,079 --> 00:30:31,011
donc, j'ai créé pour ça une autre page sur Corkami

396
00:30:31,011 --> 00:30:37,024
avec comme d'habitudes, des examples, des graphiques,

397
00:30:37,024 --> 00:30:40,073
elle n'est pas finie, mais déjà largement suffisante pour tester ou faire planter

398
00:30:40,073 --> 00:30:42,096
n'importe quel outil

399
00:30:42,096 --> 00:30:46,040
j'ai déjà une centaine d'exemples,

400
00:30:46,040 --> 00:30:51,065
qui mettent l'accent sur de nombreux aspects, avec parfois des résultats inattendus

401
00:30:51,065 --> 00:30:55,020
donc, voici une table de section virtuelle, et Hiew

402
00:30:55,020 --> 00:31:00,007
quand les alignements sont bas, on n'a pas besoin de section

403
00:31:00,007 --> 00:31:03,027
ou la table peut être vide

404
00:31:03,027 --> 00:31:08,040
donc, j'ai modifié SizeOfOptionalHeader pour qu'il pointe en espace mémoire virtuel

405
00:31:08,040 --> 00:31:11,097
donc la table des sections est en dehors du PE, pleines de zéros

406
00:31:11,097 --> 00:31:16,028
et Hiew n'aime pas ça. En conséquence, il ne pense même pas que c'est un PE

407
00:31:16,028 --> 00:31:18,088
alors que ça marche parfaitement, du moins sous XP

408
00:31:18,088 --> 00:31:27,024
car Windows 7 est plus capricieux concernant les valeurs de la table des section

409
00:31:27,024 --> 00:31:29,051
ensuite...

410
00:31:29,051 --> 00:31:34,027
si on fait de l'art dans les Data Directories

411
00:31:34,027 --> 00:31:37,020
vous pouvez commencer à vous inquieter

412
00:31:37,020 --> 00:31:40,003
si vous avez un dessin plus joli, je suis preneur

413
00:31:40,003 --> 00:31:43,031
donc, il s'agit du 'Dual PE header', présenté

414
00:31:43,031 --> 00:31:46,016
par Reversing Labs à la BlackHat

415
00:31:46,016 --> 00:31:50,031
quelqu'un connaît ?

416
00:31:50,031 --> 00:31:52,053
donc, on augmente SizeOfHeaders pour que

417
00:31:52,053 --> 00:31:59,068
les en-têtes NT soient en fait assez loin,

418
00:31:59,068 --> 00:32:04,007
pour qu'il soit aligné avec les sections

419
00:32:04,007 --> 00:32:05,053
quand il se charge en mémoire

420
00:32:05,053 --> 00:32:08,007
la première section sera chargée par dessus

421
00:32:08,007 --> 00:32:13,052
la première partie du OPTIONAL_HEADER est lue dans le fichier

422
00:32:13,052 --> 00:32:16,054
donc, prise en compte pour charger le fichier

423
00:32:16,054 --> 00:32:20,096
mais les Data Directories sont lus en mémoire

424
00:32:20,096 --> 00:32:25,003
donc, d'abord l'OPTIONAL_HEADER est analysé, chargé en mémoire,

425
00:32:25,003 --> 00:32:29,036
puis la section est dépliée sur la partie basse de l'en-tête

426
00:32:29,036 --> 00:32:31,088
et les vrais Data directories qui étaient initialement au début de la section

427
00:32:31,088 --> 00:32:34,028
vont être pris en compte,

428
00:32:34,028 --> 00:32:39,068
donc tout ceci est du pipeau présent dans le fichier, à la suite de SizeOfOptionalHeader

429
00:32:39,068 --> 00:32:45,007
mais en mémoire, ce sera écrasé et ignoré

430
00:32:45,007 --> 00:32:47,040
une autre bizarrerie est que les noms d'exports peuvent avoir n'importe quelle valeur,

431
00:32:47,040 --> 00:32:51,007
jusqu'au caractère zéro

432
00:32:51,007 --> 00:32:53,072
donc, absolument n'importe quoi,

433
00:32:53,072 --> 00:32:56,013
et de plus,

434
00:32:56,013 --> 00:32:57,052
Hiew les affichent directement

435
00:32:57,052 --> 00:32:59,038
donc on peut insérer ses propres messages

436
00:32:59,038 --> 00:33:02,055
ce sont juste des noms d'exports, d'ailleurs

437
00:33:02,055 --> 00:33:05,088
l'un d'entre eux est excessivement long,

438
00:33:05,088 --> 00:33:08,030
idéal pour tester les dépassement de tampon [buffer overflow]

439
00:33:08,030 --> 00:33:10,053
dans votre outil favori

440
00:33:10,053 --> 00:33:14,029
et il est également possible d'avoir un export avec un nom nul,

441
00:33:14,029 --> 00:33:16,038
on peut donc importer l'api nulle

442
00:33:16,038 --> 00:33:19,021
sans problème

443
00:33:19,021 --> 00:33:23,000
j'ai aussi essayé les differentes possibilités,

444
00:33:23,000 --> 00:33:26,048
avec des fichiers contenant un maximum de section,

445
00:33:26,048 --> 00:33:31,068
la limite est 96 sous XP, et 64K sous Vista et Windows 7

446
00:33:31,068 --> 00:33:33,007
ce qui donne

447
00:33:33,007 --> 00:33:36,072
avec le dernier OllyDbg 2 ce message surprenant

448
00:33:36,072 --> 00:33:38,025
mais le fichier charge quand même

449
00:33:38,025 --> 00:33:41,040
OllyDbg 1, lui, plante directement

450
00:33:41,040 --> 00:33:45,026
il reste du temps ?

451
00:33:45,026 --> 00:33:48,059
un dernier... pas très visuel

452
00:33:48,059 --> 00:33:52,068
l'adresse AddressOfIndex du TLS est mise à zéro au chargement

453
00:33:52,068 --> 00:33:59,027
et le terminus [terminator] des imports n'a pas besoin d'être composé de 5 doubles mots nuls

454
00:33:59,027 --> 00:34:03,010
mais juste d'un seul, pour son AddressOfName

455
00:34:03,010 --> 00:34:05,093
pour être considéré comme le terminus

456
00:34:05,093 --> 00:34:10,028
donc, si on fait pointer AddressOfIndex vers l'AddressOfName d'un descripteur d'imports

457
00:34:10,028 --> 00:34:15,026
s'il est mis à zéro,

458
00:34:15,026 --> 00:34:16,067
les imports seront tronqués

459
00:34:16,067 --> 00:34:20,060
et en fait, le comportement est différent sous XP ou 7

460
00:34:20,060 --> 00:34:25,085
donc, sous XP, il est écrasé après que les imports soient chargés,

461
00:34:25,085 --> 00:34:28,027
donc la table n'est pas tronquée

462
00:34:28,027 --> 00:34:32,036
alors que sous 7, il est écrasé avant les imports

463
00:34:32,036 --> 00:34:35,032
donc, pour le même PE, on a 2 comportements différents

464
00:34:35,032 --> 00:34:37,018
sous deux versions de Windows différentes,

465
00:34:37,018 --> 00:34:43,048
alors que le fichier marche sous les 2 versions.

466
00:34:43,048 --> 00:34:55,044
ah, attendez, on a encore le temps?

467
00:34:55,044 --> 00:34:56,051
15 minutes ? ok

468
00:34:56,051 --> 00:35:01,001
je vais commencer la démonstration

469
00:35:01,001 --> 00:35:23,088
pour vous montrer...

470
00:35:23,088 --> 00:35:26,008
le style de PE que je créé d'habitude

471
00:35:26,008 --> 00:35:29,010
avec le minimum d'éléments définis

472
00:35:29,010 --> 00:35:31,010
c'est en fait un pilotes [driver]

473
00:35:31,010 --> 00:35:36,088
même si j'ai utilisé des opcodes non documentés,

474
00:35:36,088 --> 00:35:40,085
ce pilote marche, sans le vrac

475
00:35:40,085 --> 00:35:43,027
habituel rajouté par le compilateurs

476
00:35:43,027 --> 00:35:47,092
donc, un exemple clair, simple

477
00:35:47,092 --> 00:35:51,046
sans rien pour vous géner la vue

478
00:35:51,046 --> 00:35:52,088
ou votre débogueur

479
00:35:52,088 --> 00:36:02,061
donc, cet exemple regarde les valeurs de CR0

480
00:36:02,061 --> 00:36:07,053
via SMSW, officiellement non défini sur un double mot

481
00:36:07,053 --> 00:36:10,000
mais en fait donne la même valeur

482
00:36:10,000 --> 00:36:11,071
que le MOV EAX, CR0 standard

483
00:36:11,071 --> 00:36:16,059
ensuite, MOV EAX, CR0 avec un 'mauvais' Mod/RM

484
00:36:16,059 --> 00:36:39,028
sous le dernier Hiew, ce n'est en fait même pas désassemblé

485
00:36:39,028 --> 00:36:43,071
on espère que ça ne plante pas...

486
00:36:43,071 --> 00:36:47,032
donc, vous voyez, on obtient les mêmes valeurs

487
00:36:47,032 --> 00:36:55,069
via le CR0 standard, l'invalide, et le non défini

488
00:36:55,069 --> 00:36:57,059
dont la partie de poid fort est non définie

489
00:36:57,059 --> 00:37:00,071
d'habitude, en langage Intel, non défini signifie 'mis à zéro',

490
00:37:00,071 --> 00:37:02,028
mais ici, on a bien CR0 entier

491
00:37:02,028 --> 00:37:03,063
et ma machine n'a même pas plantée

492
00:37:03,063 --> 00:37:05,092
ce qui signifie que le pilote fonctionne correctement

493
00:37:05,092 --> 00:37:08,046
donc vous pouvez étudier des petits pilotes

494
00:37:08,046 --> 00:37:12,045
le premier exemple présenté aujourd'hui

495
00:37:12,045 --> 00:37:15,076
était celui avec l'assembleur ancien

496
00:37:15,076 --> 00:37:20,023
quelqu'un connait le résultat final ?

497
00:37:20,023 --> 00:37:23,080
certaines instructions sont inutiles,

498
00:37:23,080 --> 00:37:28,029
juste pour vérifier que le processeur les gère

499
00:37:28,029 --> 00:37:30,088
mais d'autres modifient les registres

500
00:37:30,088 --> 00:37:37,071
et ces instructions des années 70-80

501
00:37:37,071 --> 00:37:43,088
sont toujours gérées par les processeurs modernes

502
00:37:43,088 --> 00:37:47,080
un des exemples que j'ai crée teste

503
00:37:47,080 --> 00:37:50,044
les valeurs initiales de chaques registres

504
00:37:50,044 --> 00:37:56,015
donc on peut voir les valeurs possiblesm sous XP ou W7

505
00:37:56,015 --> 00:38:01,084
à chaque fois [TLS, EntryPoint, DllMain], je sauve tous les registres

506
00:38:01,084 --> 00:38:04,003
et je compare à diverses valeurs possibles

507
00:38:04,003 --> 00:38:06,028
successivement

508
00:38:06,028 --> 00:38:10,071
en fait, au TLS, on a beaucoup de contrôles de ces valeurs,

509
00:38:10,071 --> 00:38:16,077
car ces valeurs proviennent du Data Directory

510
00:38:16,077 --> 00:38:20,021
en particulier, son adresse relative, sa taille, les callbacks...

511
00:38:20,021 --> 00:38:26,076
pour plus de détail, voir le source...

512
00:38:26,076 --> 00:38:33,063
ça vous permet d'imiter mieux un SE dans votre émulateur,

513
00:38:33,063 --> 00:38:35,055
si ça vous intéresse

514
00:38:35,055 --> 00:38:41,062
on utilise SMSW, on compare la valeur

515
00:38:41,062 --> 00:38:46,045
ensuite, après une opération FPU, on regarde si la valeur a changé

516
00:38:46,045 --> 00:38:48,080
et si elle revient à sa valeur initiale.

517
00:38:48,080 --> 00:38:52,053
une autre bizarrerie, si quelqu'un a l'explication

518
00:38:52,053 --> 00:38:54,076
est qu'en fait

519
00:38:54,076 --> 00:39:01,015
ça se comporte différemment si on exécute le fichier normalement

520
00:39:01,015 --> 00:39:04,061
ou avec une redirection

521
00:39:04,061 --> 00:39:08,046
si on redirige, 'échec'

522
00:39:08,046 --> 00:39:11,053
sinon, ça marche normalement.

523
00:39:11,053 --> 00:39:22,021
pour vous montrer... on exécute, et on lance TYPE

524
00:39:22,021 --> 00:39:24,071
normal : OK

525
00:39:24,071 --> 00:39:26,057
redirection: ECHEC

526
00:39:26,057 --> 00:39:30,066
si vous avez une explication, je suis preneur

527
00:39:30,066 --> 00:39:37,088
tu as essayé de rediriger vers autre chose ?

528
00:39:37,088 --> 00:39:42,008
non, je n'ai pas essayé

529
00:39:42,008 --> 00:39:45,024
donc, rediriger vers un autre périphérique?

530
00:39:45,024 --> 00:39:46,071
mais, comment on récupère le résultat ?

531
00:39:46,071 --> 00:39:48,017
imprimante ?

532
00:39:48,017 --> 00:39:54,025
je n'ai pas de périphérique COM

533
00:39:54,025 --> 00:39:56,076
non, je ne sais pas

534
00:39:56,076 --> 00:39:59,092
mais c'était surprenant, car je lançais tous mes tests...

535
00:39:59,092 --> 00:40:02,033
et d'un coup, 'ECHEC'...

536
00:40:02,033 --> 00:40:07,025
alors qu'à la main, aucun problème.

537
00:40:07,025 --> 00:40:09,071
l'astuce avec GS

538
00:40:09,071 --> 00:40:11,025
très simple

539
00:40:11,025 --> 00:40:19,065
et quelques affichages

540
00:40:19,065 --> 00:40:21,084
je modifie GS, qui se remet à zéro

541
00:40:21,084 --> 00:40:23,065
puis j'attend le résultat,

542
00:40:23,065 --> 00:40:26,057
ensuite je fais 2 tests et je compare le temps entre

543
00:40:26,057 --> 00:40:30,003
car ça ne doit pas arriver trop vite

544
00:40:30,003 --> 00:40:37,025
NOPs

545
00:40:37,025 --> 00:40:39,059
je teste les NOPs non documentés

546
00:40:39,059 --> 00:40:45,066
celui sur une page invalide

547
00:40:45,066 --> 00:41:01,008
NOP standard

548
00:41:01,008 --> 00:41:07,058
32 bits

549
00:41:07,058 --> 00:41:15,071
tous mes tests 64b sont fait dans des programmes 32b, car on peut les exécuter sur un OS normal

550
00:41:15,071 --> 00:41:19,033
et ensuite je regarde GS pour voir si le mode 64b est disponible

551
00:41:19,033 --> 00:41:21,067
dans ce cas, on obtiendrait un résultat différent

552
00:41:21,067 --> 00:41:26,059
donc, en 64b, que je n'ai aps ici, on obtiendrait

553
00:41:26,059 --> 00:41:28,066
les tests en 64b

554
00:41:28,066 --> 00:41:31,008
et ces results.

555
00:41:31,008 --> 00:41:35,017
mais, pas si facile à déboguer

556
00:41:35,017 --> 00:41:39,048
mais ici, pas de piège, donc on peut revenir facilement en 32b

557
00:41:39,048 --> 00:41:45,003
on saute le code 64b et revient en 32b

558
00:41:45,003 --> 00:41:48,045
PUSH/RET

559
00:41:48,045 --> 00:41:52,023
on affiche le message et ensuite...

560
00:41:52,023 --> 00:41:58,000
Olly vous dit qu'on va sauter vers [4010]08

561
00:41:58,000 --> 00:42:03,077
mais en fait - ici, c'est correct

562
00:42:03,077 --> 00:42:05,096
et le TLS a alloué la page NULLE

563
00:42:05,096 --> 00:42:09,059
qui affiche 'ECHEC'

564
00:42:09,059 --> 00:42:15,036
donc, comme mentionné auparavent, pas de façon standard de désassembler ça correctement

565
00:42:15,036 --> 00:42:23,069
je ne peux pas exécuter les 64K sections

566
00:42:23,069 --> 00:42:27,076
et en fait, cet exemple exécute tout le code (l'espace virtuel complet des 65535 sections)

567
00:42:27,076 --> 00:42:29,028
elles sont grosses,

568
00:42:29,028 --> 00:42:33,028
et je modifie EAX pour que tous les 00 00 soient exécutés

569
00:42:33,028 --> 00:42:35,070
juste pour faire un printf à la fin

570
00:42:35,070 --> 00:42:39,007
ça prend plusieurs secondes sur un i7

571
00:42:39,007 --> 00:42:43,008
c'est assez amusant: on le lance, et même avec le cache,

572
00:42:43,008 --> 00:42:50,098
et que le SE n'est pas occupé, ça prend un temps visible, juste pour un tas de 00

573
00:42:50,098 --> 00:43:00,055
les sections virtuelles... celui que le dernier Hiew ne voit pas comme un PE

574
00:43:00,055 --> 00:43:02,040
enfin, bientôt corrigé

575
00:43:02,040 --> 00:43:08,067
ah, je ne peux pas l'analyser car il ne pense même pas que c'est un PE

576
00:43:08,067 --> 00:43:13,015
mais, pour simplifier, OPTIONAL_HEADER pointe au delà 

577
00:43:13,015 --> 00:43:14,048
du fichier

578
00:43:14,048 --> 00:43:17,008
l'en-tête plié...

579
00:43:17,008 --> 00:43:18,063
quelques messages d'erreurs,

580
00:43:18,063 --> 00:43:21,007
à cause des faux Data Directories

581
00:43:21,007 --> 00:43:30,023
et les DD réels sont au début

582
00:43:30,023 --> 00:43:33,011
de la première section

583
00:43:33,011 --> 00:43:42,048
ceci deviendra les imports, et le vrai Data Directory

584
00:43:42,048 --> 00:43:49,026
et pour finir, celui avec TLS AddressOfIndex qui pointe...

585
00:43:49,026 --> 00:44:02,040
...dans les descripteurs d'imports, sur AddressOfName

586
00:44:02,040 --> 00:44:04,040
donc, il sera écrasé au chargement

587
00:44:04,040 --> 00:44:11,092
et quand on le charge, il reconnait XP

588
00:44:11,092 --> 00:44:14,071
à la façon dont les imports ont été chargés

589
00:44:14,071 --> 00:44:17,017
et sous 7, on obtiendra un autre résultat.

590
00:44:17,017 --> 00:44:19,059
pour finir, les exports

591
00:44:19,059 --> 00:44:24,059
certains ont des noms très longs

592
00:44:24,059 --> 00:44:30,050
en fait, on remarque que j'écrase le désassemblage même

593
00:44:30,050 --> 00:44:33,096
donc je répète les faux opcodes et adresses

594
00:44:33,096 --> 00:44:37,059
donc le désassembleur est perturbé

595
00:44:37,059 --> 00:44:40,051
mais c'est juste visuel, pas vraiment grave

596
00:44:40,051 --> 00:44:43,018
bien que ce soit un problème récent dans IDA

597
00:44:43,018 --> 00:44:47,008
ou si on met un export au milieu d'une instruction

598
00:44:47,008 --> 00:44:49,076
l'export aura priorité sur le désassemblage,

599
00:44:49,076 --> 00:44:52,011
et casse l'instruction en deux

600
00:44:52,011 --> 00:44:58,050
il y a bien sûr un exemple pour ça sur Corkami

601
00:44:58,050 --> 00:45:05,010
donc, voilà pour les démonstrations

602
00:45:05,010 --> 00:45:10,016
Je voulais donc en savoir plus sur le x86 et le PE

603
00:45:10,016 --> 00:45:12,067
qui sont loin d'être correctement documentés

604
00:45:12,067 --> 00:45:14,080
et qui ne le sont toujours pas,

605
00:45:14,080 --> 00:45:18,048
mais j'en ai couvert un peu

606
00:45:18,048 --> 00:45:20,042
il y a encore des flous

607
00:45:20,042 --> 00:45:24,009
mais de moins en moins, j'y travaille

608
00:45:24,009 --> 00:45:27,057
en publiant mes recherches librement

609
00:45:27,057 --> 00:45:31,080
tel WinDbg, si vous suivez les documentations officielles à la lettre,

610
00:45:31,080 --> 00:45:36,017
vous êtes voués à l'échec, surtout avec tous les virus et packeurs existants

611
00:45:36,017 --> 00:45:40,063
si vous êtes intéressés, ou que vous programmez un outil, un émulateur, un moteur...

612
00:45:40,063 --> 00:45:44,057
vous savez que vous pouvez aller sur Corkami, lire les pages

613
00:45:44,057 --> 00:45:48,024
télécharger les exemples, qui sont disponibles librement, à tout point de vue

614
00:45:48,024 --> 00:45:50,076
et si vous trouvez des bugs, ce qui pourrait arriver

615
00:45:50,076 --> 00:45:57,007
envoyez-moi une carte postale, ou un t-shirt croix rouge ;)

616
00:45:57,007 --> 00:46:01,076
Merci à Peter Ferrie, et tous mes relecteurs et contributeurs

617
00:46:01,076 --> 00:46:03,066
vous avez des questions ?

618
00:46:03,066 --> 00:46:10,081
tu les as testés sur des anti-virus ? tu devrais trouver une ch*ée de 0days

619
00:46:10,081 --> 00:46:23,096
mouai, non, je ne saurais pas en faire des exploits...

620
00:46:23,096 --> 00:46:29,000
tenir en échec les désassembleurs me suffit

621
00:46:29,000 --> 00:46:40,025
j'ai trouvé un crash dans Xed d'Intel, ça me suffit

622
00:46:40,025 --> 00:46:45,000
une autre question ? tout le monde a survécu ?

623
00:46:45,000 --> 00:46:46,055
c'était une super présentation, mec

624
00:46:46,059 --> 00:46:48,023
merci!

625
00:46:48,023 --> 00:46:50,070
MERCI!
